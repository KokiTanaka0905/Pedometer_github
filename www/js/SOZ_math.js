


let	SOZ_PI = 3.141592653589793;
let sin_box = [ 0x10000 ], cos_box = [ 0x10000 ];					//360度





//-----------------------------------------------------------------------------
//三角関数の初期化
//-----------------------------------------------------------------------------
function SOZ_sinbox_init()
{
	let i;

	for( i = 0; i <= 0xFFFF; i++)
	{
		// 元の三角関数はRad
		sin_box[ i ] = Math.sin( ( SOZ_PI * i / 0x10000 ) * 2 );
		cos_box[ i ] = Math.cos( ( SOZ_PI * i / 0x10000 ) * 2 );
	}
}

//-----------------------------------------------------------------------------
//三角関数 SINの出力
//-----------------------------------------------------------------------------
function SOZ_get_SIN( ang )
{
	let d = Math.floor( ang );
	d &= 0xffff;				//高速化のために変更
	return sin_box[ d ];
}


//-----------------------------------------------------------------------------
//三角関数 COSの出力
//-----------------------------------------------------------------------------
function SOZ_get_COS( ang )
{
	let d = Math.floor( ang );
	d &= 0xffff;				//高速化のために変更
	return cos_box[ d ];
}

//-----------------------------------------------------------------------------
//SOZ角をラジアンに変更
//-----------------------------------------------------------------------------
function SOZ_Radian( angle )
{
	return ((3.14159  / (0x10000 / 2)) * angle);
}








//-------------------------------------------------------------------------------------------
//	角度の差を出す		
//
//	いちいち用意すると案外めんどくさいので関数化。
//	円という性質上角度は２つ(合計で0x10000度)出来上がるがその中でも、小さい方を取得させる。
//	また、差分は方向で ang_a から ang_bはどれだけ「大きい、小さい」を算出する必要があるため
//	戻り値には、マイナス（左回り）、プラス（右回り）の概念もある。
//
//-------------------------------------------------------------------------------------------

function SOZ_angle_diff( ang_a, ang_b )
{
	let	wk_ang_b, sa;
//	let wk_ang_a;

	wk_ang_b = ( ( ang_b & 0xffff ) - ( ang_a & 0xffff ) );		//Aをゼロを基準にした場合のBの位置を算出、その最１６ビット演算をする
	wk_ang_b &= 0xffff;				//マイナスを外す
//	wk_ang_a = 0;					//Aの地点はゼロになる。今後このソースコードで出てこないので注釈にする

	sa = Math.abs( wk_ang_b ); 		//絶対値を作り出す。
	if( wk_ang_b >= 0x8000 )		//この数値よりも大きいということは、逆から回り込んだほうが目的地に近いということ。
		sa = -( 0x10000 - sa );		//方向が負の数値になる（ -0x0001 ～  -0x7fff)

	return sa;
}















//-----------------------------------------------------------------------------
//	ポイントまで減速移動
//-----------------------------------------------------------------------------
function point_setting( ap )
{
	let	sx,sy;

	sx = pos_x[ ap ] - keep_x[ ap ];	//まず、差を算出
	sy = pos_y[ ap ] - keep_y[ ap ];

	if ( Math.abs( sx ) < WP / 2 && Math.abs(sy) < WP / 2)
	{
		pos_x[ ap ] = keep_x[ ap ];
		pos_y[ ap ] = keep_y[ ap ];
		return	-1;
	}	

	sx= sx / (1 + keep_spd[ ap ]);
	sy= sy / (1 + keep_spd[ ap ]);
	pos_x[ ap ] -= sx;
	pos_y[ ap ] -= sy;
	
	return 0;
}



